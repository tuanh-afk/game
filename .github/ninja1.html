<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ninja Runner (Dino-style)</title>
  <style>
    :root{
      --bg:#ffffff;
      --ink:#111827;
      --muted:#6b7280;
      --line:#e5e7eb;
      --card:#ffffff;
      --shadow: 0 10px 30px rgba(0,0,0,.08);
      --accent:#ef4444;
      --accent2:#2563eb;
      --good:#10b981;
    }
    *{box-sizing:border-box;}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--ink);
      background:linear-gradient(180deg,#ffffff 0%, #ffffff 55%, #f8fafc 100%);
    }
    .wrap{
      max-width:1100px;
      margin:0 auto;
      padding:20px;
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:16px;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns: 1fr;}
    }
    .panel{
      background:var(--card);
      border:1px solid var(--line);
      border-radius:18px;
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .topbar{
      padding:14px 16px;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      border-bottom:1px solid var(--line);
      background:#fff;
    }
    .title{
      display:flex;
      align-items:center;
      gap:10px;
      font-weight:800;
    }
    .badge{
      font-size:12px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      color:var(--muted);
    }
    .controls{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    select, input, button{
      font:inherit;
    }
    select, input{
      border:1px solid var(--line);
      border-radius:12px;
      padding:9px 10px;
      background:#fff;
      outline:none;
    }
    button{
      border:1px solid var(--line);
      background:#fff;
      border-radius:12px;
      padding:9px 12px;
      cursor:pointer;
      transition:transform .06s ease;
    }
    button:active{transform:translateY(1px);}
    .btn-primary{
      border-color:transparent;
      background:linear-gradient(135deg,var(--accent),#fb7185);
      color:#fff;
      font-weight:700;
    }
    .btn-ghost{
      background:#fff;
      color:var(--ink);
    }
    .btn-muted{
      background:#f9fafb;
    }

    .game-area{
      position:relative;
      width:100%;
      aspect-ratio: 16 / 6;
      min-height:320px;
      background:#fff;
      overflow:hidden;
    }
    canvas{display:block; width:100%; height:100%;}

    .hud{
      position:absolute;
      left:14px;
      top:12px;
      display:flex;
      gap:10px;
      align-items:center;
      z-index:5;
      user-select:none;
      pointer-events:none;
    }
    .pill{
      pointer-events:none;
      background:rgba(255,255,255,.85);
      border:1px solid var(--line);
      border-radius:999px;
      padding:6px 10px;
      font-size:13px;
      color:var(--ink);
      backdrop-filter: blur(6px);
    }

    .overlay{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:10;
      background:rgba(255,255,255,.86);
      backdrop-filter: blur(6px);
    }
    .modal{
      width:min(520px, 92%);
      background:#fff;
      border:1px solid var(--line);
      border-radius:18px;
      box-shadow:var(--shadow);
      padding:16px;
    }
    .modal h2{margin:0 0 8px 0; font-size:20px;}
    .modal p{margin:0 0 12px 0; color:var(--muted); line-height:1.4;}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .row > *{flex:1;}
    .hint{font-size:13px; color:var(--muted); margin-top:10px;}

    .side{
      padding:14px;
    }
    .side h3{margin:0 0 8px 0; font-size:16px;}
    .side p{margin:0 0 10px 0; color:var(--muted); font-size:13px; line-height:1.4;}
    .leaderboard{
      margin-top:10px;
      border:1px solid var(--line);
      border-radius:16px;
      overflow:hidden;
    }
    .lb-head{
      display:flex;
      justify-content:space-between;
      padding:10px 12px;
      background:#f9fafb;
      border-bottom:1px solid var(--line);
      font-weight:700;
      font-size:13px;
    }
    .lb-list{max-height:340px; overflow:auto;}
    .lb-item{
      display:flex;
      justify-content:space-between;
      padding:10px 12px;
      border-bottom:1px solid #f3f4f6;
      font-size:14px;
    }
    .lb-item:last-child{border-bottom:none;}
    .k{color:var(--muted); font-size:12px;}

    .mobile-keys{
      display:none;
      gap:10px;
      padding:12px;
      border-top:1px solid var(--line);
      background:#fff;
    }
    .mobile-keys button{flex:1; padding:14px 12px; font-weight:800;}
    @media (max-width: 980px){
      .mobile-keys{display:flex;}
    }
  </style>
</head>
<body>
  <div class="wrap">

    <div class="panel">
      <div class="topbar">
        <div class="title">
          ü•∑ Ninja Runner
          <span class="badge">Dino-style</span>
        </div>
        <div class="controls">
          <select id="difficulty">
            <option value="easy">D·ªÖ</option>
            <option value="medium" selected>Trung b√¨nh</option>
            <option value="hard">Kh√≥</option>
          </select>
          <button id="muteBtn" class="btn-muted" title="B·∫≠t/T·∫Øt √¢m thanh">üîä Sound</button>
          <button id="startBtn" class="btn-primary">B·∫Øt ƒë·∫ßu</button>
          <button id="resetBtn" class="btn-ghost">Reset</button>
        </div>
      </div>

      <div class="game-area">
        <canvas id="c"></canvas>

        <div class="hud">
          <div class="pill">ƒêi·ªÉm: <b id="score">0</b></div>
          <div class="pill">T·ªëc ƒë·ªô: <b id="spd">1.0</b>x</div>
        </div>

        <div id="overlay" class="overlay">
          <div class="modal">
            <h2 id="overlayTitle">Ninja Runner</h2>
            <p id="overlayDesc">Nh·∫≠p t√™n, ch·ªçn ƒë·ªô kh√≥, b·∫•m <b>B·∫Øt ƒë·∫ßu</b>. Nh·∫•n <b>Space/‚Üë</b> ƒë·ªÉ nh·∫£y, <b>‚Üì</b> ƒë·ªÉ c√∫i.</p>
            <div class="row">
              <input id="playerName" maxlength="16" placeholder="T√™n ng∆∞·ªùi ch∆°i (vd: Bonie)" />
              <button id="playBtn" class="btn-primary">B·∫Øt ƒë·∫ßu</button>
            </div>
            <div class="hint">M·∫πo: ch∆∞·ªõng ng·∫°i tr√™n s·∫Ω <b>ƒë·ª•ng</b> n·∫øu b·∫°n kh√¥ng c√∫i.</div>
          </div>
        </div>
      </div>

      <div class="mobile-keys">
        <button id="btnJump">‚¨ÜÔ∏è Nh·∫£y</button>
        <button id="btnDuck">‚¨áÔ∏è C√∫i</button>
      </div>
    </div>

    <div class="panel side">
      <h3>üìå H∆∞·ªõng d·∫´n</h3>
      <p>
        - <b>Space / ‚Üë</b>: Nh·∫£y<br>
        - <b>‚Üì</b>: C√∫i (gi·ªØ)<br>
        - M·ªói <b>10 ƒëi·ªÉm</b>: ting üéµ<br>
        - TOP 10 l∆∞u b·∫±ng <b>localStorage</b>
      </p>

      <div class="leaderboard">
        <div class="lb-head">
          <span>üèÜ TOP 10</span>
          <span class="k">T√™n ¬∑ ƒêi·ªÉm</span>
        </div>
        <div id="lb" class="lb-list"></div>
      </div>

      <div style="margin-top:12px; display:flex; gap:8px;">
        <button id="clearLb" class="btn-ghost" style="flex:1;">Xo√° BXH</button>
      </div>

      <p style="margin-top:12px;">
        <span class="k">N·ªÅn s√°ng + background Nh·∫≠t: Ph√∫ Sƒ©, torii, m√¢y. Ninja chibi. Ch∆∞·ªõng ng·∫°i v·∫Ω l·∫°i ƒë·ªìng b·ªô.</span>
      </p>
    </div>

  </div>

<script>
(() => {
  // =====================
  // Canvas setup
  // =====================
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  function fitCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  // =====================
  // UI
  // =====================
  const overlay = document.getElementById('overlay');
  const overlayTitle = document.getElementById('overlayTitle');
  const overlayDesc = document.getElementById('overlayDesc');

  const startBtn = document.getElementById('startBtn');
  const resetBtn = document.getElementById('resetBtn');
  const playBtn = document.getElementById('playBtn');
  const muteBtn = document.getElementById('muteBtn');

  const scoreEl = document.getElementById('score');
  const spdEl = document.getElementById('spd');

  const difficultySel = document.getElementById('difficulty');
  const playerNameInput = document.getElementById('playerName');

  const lbEl = document.getElementById('lb');
  const clearLbBtn = document.getElementById('clearLb');

  const btnJump = document.getElementById('btnJump');
  const btnDuck = document.getElementById('btnDuck');

  // =====================
  // Audio (WebAudio: ting)
  // =====================
  let audioCtx = null;
  let muted = false;

  function ensureAudio(){
    if(!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
  }

  function ting(){
    if(muted) return;
    ensureAudio();
    const t = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();

    o.type = 'sine';
    o.frequency.setValueAtTime(880, t);
    o.frequency.exponentialRampToValueAtTime(1320, t + 0.08);

    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.18, t + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t + 0.16);

    o.connect(g);
    g.connect(audioCtx.destination);

    o.start(t);
    o.stop(t + 0.17);
  }

  function updateMuteBtn(){
    muteBtn.textContent = muted ? 'üîá Muted' : 'üîä Sound';
  }
  updateMuteBtn();

  muteBtn.addEventListener('click', () => {
    muted = !muted;
    updateMuteBtn();
  });

  // =====================
  // Leaderboard
  // =====================
  const LB_KEY = 'ninja_runner_top10_v1';

  function loadLB(){
    try{
      const raw = localStorage.getItem(LB_KEY);
      if(!raw) return [];
      const arr = JSON.parse(raw);
      if(!Array.isArray(arr)) return [];
      return arr
        .filter(x => x && typeof x.name === 'string' && typeof x.score === 'number')
        .map(x => ({name: x.name.slice(0,16), score: Math.max(0, Math.floor(x.score))}))
        .sort((a,b) => b.score - a.score)
        .slice(0,10);
    }catch{
      return [];
    }
  }

  function saveLB(list){
    localStorage.setItem(LB_KEY, JSON.stringify(list.slice(0,10)));
  }

  function renderLB(){
    const list = loadLB();
    lbEl.innerHTML = '';
    if(list.length === 0){
      const div = document.createElement('div');
      div.className = 'lb-item';
      div.innerHTML = '<span class="k">Ch∆∞a c√≥ ƒëi·ªÉm. Ch∆°i ngay!</span><span class="k">‚Äî</span>';
      lbEl.appendChild(div);
      return;
    }
    list.forEach((x, i) => {
      const div = document.createElement('div');
      div.className = 'lb-item';
      div.innerHTML = `<span>${i+1}. <b>${escapeHtml(x.name)}</b></span><span><b>${x.score}</b></span>`;
      lbEl.appendChild(div);
    });
  }

  function escapeHtml(s){
    return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  clearLbBtn.addEventListener('click', () => {
    localStorage.removeItem(LB_KEY);
    renderLB();
  });

  renderLB();

  // =====================
  // Game constants
  // =====================
  const W = () => canvas.getBoundingClientRect().width;
  const H = () => canvas.getBoundingClientRect().height;

  const GROUND_Y_RATIO = 0.82; // ground line position

  const DIFF = {
    easy:   { baseSpeed: 270, accel: 0.020, spawnMin: 0.95, spawnMax: 1.55 },
    medium: { baseSpeed: 320, accel: 0.030, spawnMin: 0.80, spawnMax: 1.35 },
    hard:   { baseSpeed: 380, accel: 0.045, spawnMin: 0.68, spawnMax: 1.15 },
  };

  // Jump tuning (NOT too high, NOT too low)
  const JUMP = {
    vy: -560,          // initial jump velocity
    gravity: 1750,     // gravity
    maxHoldMs: 140,    // small variable jump
  };

  // =====================
  // Game state
  // =====================
  let running = false;
  let gameOver = false;
  let countdown = 0;
  let countdownStart = 0;

  let playerName = '';

  let score = 0;
  let lastTingBucket = 0;

  let time = 0;
  let speed = 1;

  let obstacles = [];
  let nextSpawnIn = 0;

  let keys = { jump:false, duck:false };

  // =====================
  // Ninja (chibi)
  // =====================
  const ninja = {
    x: 90,
    y: 0,
    w: 62,
    h: 62,
    vy: 0,
    onGround: true,
    ducking: false,
    jumpHoldStart: 0,
    anim: 0,
  };

  function groundY(){
    return H() * GROUND_Y_RATIO;
  }

  function ninjaHitbox(){
    // Slightly forgiving hitbox
    const padX = 10;
    const padY = 8;
    const w = ninja.ducking ? ninja.w * 0.95 : ninja.w * 0.92;
    const h = ninja.ducking ? ninja.h * 0.62 : ninja.h * 0.92;
    const x = ninja.x + padX;
    const y = ninja.y + (ninja.ducking ? 18 : padY);
    return {x, y, w, h};
  }

  // =====================
  // Obstacles (redrawn, clear, not huge)
  // =====================
  // Two types: ground & overhead (forces duck)
  const OB_TYPES = [
    { id:'takoyaki', kind:'ground' },
    { id:'ramen', kind:'ground' },
    { id:'sushi', kind:'ground' },
    { id:'tempura', kind:'ground' },
    { id:'daruma', kind:'ground' },
    { id:'maneki', kind:'ground' },
    { id:'lantern', kind:'over' },
    { id:'banner', kind:'over' },
  ];

  function makeObstacle(typeId, kind){
    const gy = groundY();

    // Sizes tuned to be reasonable
    let w = 46, h = 46;

    if(kind === 'over'){
      // Overhead obstacles must be low enough to force duck
      w = 64; h = 34;
    }

    const x = W() + 40;

    let y;
    if(kind === 'ground'){
      y = gy - h;
    }else{
      // FIX: Overhead obstacle must be LOW enough so STANDING collides, DUCK clears.
      // Standing hitbox top ~ gy-54, duck hitbox top ~ gy-44.
      // We place the obstacle so its bottom sits around gy-46.
      // (Standing will intersect; duck will pass.)
      y = gy - 80;
    }

    return {
      id: typeId,
      kind,
      x, y, w, h,
    };
  }

  function obstacleHitbox(o){
    // slightly forgiving
    const pad = 6;
    return {x:o.x+pad, y:o.y+pad, w:o.w-2*pad, h:o.h-2*pad};
  }

  // =====================
  // Background: Fuji + torii + clouds (bright)
  // =====================
  function drawBackground(t){
    const w = W();
    const h = H();
    const gy = groundY();

    // Sky
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,w,h);

    // Soft sky gradient band
    const g = ctx.createLinearGradient(0,0,0,gy);
    g.addColorStop(0,'#ffffff');
    g.addColorStop(1,'#f8fafc');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,gy);

    // Distant clouds (parallax)
    const cloudY = gy - 190;
    const cloudScroll = (t * 14) % (w + 260);
    for(let i=0;i<4;i++){
      const cx = w - cloudScroll + i*260;
      drawCloud(cx, cloudY + (i%2)*14, 1.0);
    }

    // Fuji
    const fujiX = w*0.72;
    const fujiBaseY = gy + 4;
    drawFuji(fujiX, fujiBaseY, 220);

    // Torii
    const toriiX = w*0.22;
    const toriiY = gy + 2;
    drawTorii(toriiX, toriiY, 130);

    // Ground line
    ctx.strokeStyle = '#e5e7eb';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, gy);
    ctx.lineTo(w, gy);
    ctx.stroke();

    // Tiny ground dots
    const dotScroll = (t * 220) % 30;
    ctx.fillStyle = '#e5e7eb';
    for(let x = -dotScroll; x < w; x += 30){
      ctx.fillRect(x, gy+10, 10, 2);
    }
  }

  function drawCloud(x,y,scale){
    ctx.save();
    ctx.translate(x,y);
    ctx.scale(scale,scale);
    ctx.globalAlpha = 0.75;
    ctx.fillStyle = '#eef2ff';
    roundedBlob(0,0,90,30,16);
    roundedBlob(20,-14,44,28,14);
    roundedBlob(50,-10,52,26,14);
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function roundedBlob(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y, x+w,y+h, r);
    ctx.arcTo(x+w,y+h, x,y+h, r);
    ctx.arcTo(x,y+h, x,y, r);
    ctx.arcTo(x,y, x+w,y, r);
    ctx.closePath();
    ctx.fill();
  }

  function drawFuji(cx, baseY, size){
    // Mountain
    const w = size;
    const h = size*0.62;
    const left = cx - w/2;
    const top = baseY - h;

    // body
    ctx.fillStyle = '#cbd5e1';
    ctx.beginPath();
    ctx.moveTo(cx, top);
    ctx.lineTo(left, baseY);
    ctx.lineTo(left+w, baseY);
    ctx.closePath();
    ctx.fill();

    // shade
    ctx.fillStyle = '#94a3b8';
    ctx.beginPath();
    ctx.moveTo(cx, top);
    ctx.lineTo(cx, baseY);
    ctx.lineTo(left+w, baseY);
    ctx.closePath();
    ctx.fill();

    // snow cap
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.moveTo(cx, top);
    ctx.lineTo(cx - w*0.12, top + h*0.22);
    ctx.lineTo(cx - w*0.04, top + h*0.26);
    ctx.lineTo(cx, top + h*0.18);
    ctx.lineTo(cx + w*0.05, top + h*0.26);
    ctx.lineTo(cx + w*0.13, top + h*0.22);
    ctx.closePath();
    ctx.fill();

    // outline (subtle)
    ctx.strokeStyle = '#e5e7eb';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx, top);
    ctx.lineTo(left, baseY);
    ctx.lineTo(left+w, baseY);
    ctx.closePath();
    ctx.stroke();
  }

  function drawTorii(x, baseY, size){
    const w = size;
    const h = size*0.85;
    const left = x - w/2;
    const top = baseY - h;

    // legs
    ctx.fillStyle = '#ef4444';
    ctx.fillRect(left + w*0.18, top + h*0.18, w*0.12, h*0.67);
    ctx.fillRect(left + w*0.70, top + h*0.18, w*0.12, h*0.67);

    // crossbar
    ctx.fillRect(left + w*0.08, top + h*0.12, w*0.84, h*0.10);
    // top bar
    ctx.fillRect(left, top, w, h*0.10);

    // small center
    ctx.fillStyle = '#111827';
    ctx.globalAlpha = 0.12;
    ctx.fillRect(left + w*0.46, top + h*0.22, w*0.08, h*0.18);
    ctx.globalAlpha = 1;

    // outline
    ctx.strokeStyle = '#fecaca';
    ctx.lineWidth = 2;
    ctx.strokeRect(left + w*0.18, top + h*0.18, w*0.12, h*0.67);
    ctx.strokeRect(left + w*0.70, top + h*0.18, w*0.12, h*0.67);
  }

  // =====================
  // Drawing: Ninja (chibi)
  // =====================
  function drawNinja(){
    const x = ninja.x;
    const y = ninja.y;
    const w = ninja.w;
    const h = ninja.h;

    // animation (run)
    const t = ninja.anim;
    const leg = Math.sin(t*10) * 5;
    const arm = Math.sin(t*10 + 1.2) * 4;

    ctx.save();
    ctx.translate(x, y);

    // Shadow
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = '#111827';
    ctx.beginPath();
    ctx.ellipse(w*0.52, h*0.96, w*0.32, h*0.10, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // If ducking: squash a bit
    const squat = ninja.ducking ? 0.80 : 1.0;
    ctx.translate(0, ninja.ducking ? 10 : 0);
    ctx.scale(1, squat);

    // Body
    ctx.fillStyle = '#111827';
    roundRect(14, 22, 36, 30, 12);
    ctx.fill();

    // Belt
    ctx.fillStyle = '#2563eb';
    roundRect(16, 40, 32, 8, 6);
    ctx.fill();

    // Head
    ctx.fillStyle = '#111827';
    ctx.beginPath();
    ctx.ellipse(32, 18, 18, 16, 0, 0, Math.PI*2);
    ctx.fill();

    // Face window
    ctx.fillStyle = '#fde68a';
    ctx.beginPath();
    ctx.ellipse(32, 20, 12, 9, 0, 0, Math.PI*2);
    ctx.fill();

    // Eyes
    ctx.fillStyle = '#111827';
    ctx.beginPath();
    ctx.ellipse(28, 20, 2.2, 2.8, 0, 0, Math.PI*2);
    ctx.ellipse(36, 20, 2.2, 2.8, 0, 0, Math.PI*2);
    ctx.fill();

    // Headband knot
    ctx.fillStyle = '#ef4444';
    ctx.beginPath();
    ctx.roundRect(18, 10, 28, 6, 4);
    ctx.fill();

    // Headband tails
    ctx.strokeStyle = '#ef4444';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(46, 12);
    ctx.lineTo(58, 6);
    ctx.moveTo(46, 14);
    ctx.lineTo(58, 14);
    ctx.stroke();

    // Arms
    ctx.strokeStyle = '#111827';
    ctx.lineWidth = 8;
    ctx.lineCap = 'round';
    // left
    ctx.beginPath();
    ctx.moveTo(16, 30);
    ctx.lineTo(10, 38 + arm);
    ctx.stroke();
    // right
    ctx.beginPath();
    ctx.moveTo(48, 30);
    ctx.lineTo(56, 38 - arm);
    ctx.stroke();

    // Legs
    ctx.strokeStyle = '#111827';
    ctx.lineWidth = 9;
    // left
    ctx.beginPath();
    ctx.moveTo(26, 52);
    ctx.lineTo(18, 60 + leg);
    ctx.stroke();
    // right
    ctx.beginPath();
    ctx.moveTo(38, 52);
    ctx.lineTo(46, 60 - leg);
    ctx.stroke();

    // Shoes
    ctx.fillStyle = '#0f172a';
    ctx.beginPath();
    ctx.roundRect(12, 60 + leg, 14, 8, 4);
    ctx.roundRect(38, 60 - leg, 14, 8, 4);
    ctx.fill();

    // Outline subtle
    ctx.globalAlpha = 0.15;
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.strokeRect(0,0,0,0);
    ctx.globalAlpha = 1;

    ctx.restore();
  }

  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y, x+w,y+h, r);
    ctx.arcTo(x+w,y+h, x,y+h, r);
    ctx.arcTo(x,y+h, x,y, r);
    ctx.arcTo(x,y, x+w,y, r);
    ctx.closePath();
  }

  // =====================
  // Drawing: Obstacles (new clear drawings)
  // =====================
  function drawObstacle(o){
    ctx.save();
    ctx.translate(o.x, o.y);

    // outline helper
    const outline = () => {
      ctx.globalAlpha = 0.12;
      ctx.strokeStyle = '#111827';
      ctx.lineWidth = 2;
      ctx.strokeRect(1,1,o.w-2,o.h-2);
      ctx.globalAlpha = 1;
    };

    switch(o.id){
      case 'takoyaki': drawTakoyaki(o.w,o.h); break;
      case 'ramen': drawRamen(o.w,o.h); break;
      case 'sushi': drawSushi(o.w,o.h); break;
      case 'tempura': drawTempura(o.w,o.h); break;
      case 'daruma': drawDaruma(o.w,o.h); break;
      case 'maneki': drawManeki(o.w,o.h); break;
      case 'lantern': drawLantern(o.w,o.h); break;
      case 'banner': drawBanner(o.w,o.h); break;
      default:
        ctx.fillStyle = '#111827';
        ctx.fillRect(0,0,o.w,o.h);
    }

    outline();
    ctx.restore();
  }

  function drawTakoyaki(w,h){
    // 3 balls in a tray
    ctx.fillStyle = '#b45309';
    ctx.beginPath();
    ctx.roundRect(4, h*0.52, w-8, h*0.40, 10);
    ctx.fill();

    const balls = [
      {x:w*0.28,y:h*0.48},{x:w*0.52,y:h*0.44},{x:w*0.72,y:h*0.50}
    ];
    balls.forEach((b,i)=>{
      ctx.fillStyle = '#f59e0b';
      ctx.beginPath();
      ctx.ellipse(b.x,b.y, w*0.16, h*0.16, 0,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#92400e';
      ctx.globalAlpha = 0.18;
      ctx.beginPath();
      ctx.ellipse(b.x+3,b.y+3, w*0.14, h*0.14, 0,0,Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // mayo line
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(b.x-7,b.y-4);
      ctx.lineTo(b.x+7,b.y+4);
      ctx.stroke();

      // seaweed
      ctx.fillStyle = '#14532d';
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.ellipse(b.x-4,b.y-8, 3,2,0,0,Math.PI*2);
      ctx.ellipse(b.x+6,b.y-2, 3,2,0,0,Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    });
  }

  function drawRamen(w,h){
    // bowl
    ctx.fillStyle = '#2563eb';
    ctx.beginPath();
    ctx.roundRect(6, h*0.44, w-12, h*0.48, 12);
    ctx.fill();

    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.roundRect(8, h*0.48, w-16, h*0.34, 10);
    ctx.fill();

    // soup
    ctx.fillStyle = '#fbbf24';
    ctx.beginPath();
    ctx.roundRect(10, h*0.50, w-20, h*0.28, 10);
    ctx.fill();

    // noodles
    ctx.strokeStyle = '#fef3c7';
    ctx.lineWidth = 3;
    for(let i=0;i<4;i++){
      ctx.beginPath();
      ctx.moveTo(14, h*0.56 + i*6);
      ctx.bezierCurveTo(w*0.35, h*0.50 + i*6, w*0.65, h*0.68 + i*6, w-14, h*0.56 + i*6);
      ctx.stroke();
    }

    // egg
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.ellipse(w*0.70, h*0.60, 9, 7, 0,0,Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#f59e0b';
    ctx.beginPath();
    ctx.ellipse(w*0.70, h*0.60, 4, 4, 0,0,Math.PI*2);
    ctx.fill();

    // chopsticks
    ctx.strokeStyle = '#92400e';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(w*0.12, h*0.18);
    ctx.lineTo(w*0.88, h*0.40);
    ctx.moveTo(w*0.18, h*0.10);
    ctx.lineTo(w*0.92, h*0.32);
    ctx.stroke();
  }

  function drawSushi(w,h){
    // rice
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.roundRect(8, h*0.44, w-16, h*0.40, 14);
    ctx.fill();

    // nori wrap
    ctx.fillStyle = '#0f172a';
    ctx.globalAlpha = 0.85;
    ctx.beginPath();
    ctx.roundRect(8, h*0.58, w-16, h*0.26, 12);
    ctx.fill();
    ctx.globalAlpha = 1;

    // salmon
    ctx.fillStyle = '#fb7185';
    ctx.beginPath();
    ctx.roundRect(10, h*0.32, w-20, h*0.22, 14);
    ctx.fill();

    // salmon lines
    ctx.strokeStyle = '#fecdd3';
    ctx.lineWidth = 2;
    for(let i=0;i<3;i++){
      ctx.beginPath();
      ctx.moveTo(14+i*10, h*0.36);
      ctx.lineTo(22+i*10, h*0.50);
      ctx.stroke();
    }
  }

  function drawTempura(w,h){
    // shrimp tempura
    ctx.fillStyle = '#f59e0b';
    ctx.beginPath();
    ctx.roundRect(8, h*0.38, w*0.68, h*0.42, 16);
    ctx.fill();

    // tail
    ctx.fillStyle = '#fb7185';
    ctx.beginPath();
    ctx.moveTo(w*0.76, h*0.46);
    ctx.lineTo(w*0.92, h*0.36);
    ctx.lineTo(w*0.92, h*0.72);
    ctx.closePath();
    ctx.fill();

    // crunchy bits
    ctx.fillStyle = '#fde68a';
    for(let i=0;i<8;i++){
      ctx.beginPath();
      ctx.ellipse(12+i*6, h*0.34 + (i%2)*4, 3,2,0,0,Math.PI*2);
      ctx.fill();
    }
  }

  function drawDaruma(w,h){
    // body
    ctx.fillStyle = '#ef4444';
    ctx.beginPath();
    ctx.ellipse(w*0.50, h*0.58, w*0.34, h*0.34, 0,0,Math.PI*2);
    ctx.fill();

    // face
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.ellipse(w*0.50, h*0.56, w*0.22, h*0.18, 0,0,Math.PI*2);
    ctx.fill();

    // eyes
    ctx.fillStyle = '#111827';
    ctx.beginPath();
    ctx.ellipse(w*0.44, h*0.54, 3,4,0,0,Math.PI*2);
    ctx.ellipse(w*0.56, h*0.54, 3,4,0,0,Math.PI*2);
    ctx.fill();

    // brow
    ctx.strokeStyle = '#111827';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(w*0.40, h*0.48);
    ctx.lineTo(w*0.48, h*0.50);
    ctx.moveTo(w*0.60, h*0.48);
    ctx.lineTo(w*0.52, h*0.50);
    ctx.stroke();

    // mouth
    ctx.strokeStyle = '#111827';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(w*0.50, h*0.62, 7, 0, Math.PI);
    ctx.stroke();

    // gold belly
    ctx.fillStyle = '#fbbf24';
    ctx.globalAlpha = 0.85;
    ctx.beginPath();
    ctx.roundRect(w*0.36, h*0.68, w*0.28, h*0.16, 10);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  function drawManeki(w,h){
    // cat body
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.roundRect(10, h*0.42, w-20, h*0.44, 14);
    ctx.fill();

    // head
    ctx.beginPath();
    ctx.ellipse(w*0.50, h*0.34, w*0.22, h*0.18, 0,0,Math.PI*2);
    ctx.fill();

    // ears
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.moveTo(w*0.40, h*0.24);
    ctx.lineTo(w*0.34, h*0.14);
    ctx.lineTo(w*0.46, h*0.18);
    ctx.closePath();
    ctx.moveTo(w*0.60, h*0.24);
    ctx.lineTo(w*0.66, h*0.14);
    ctx.lineTo(w*0.54, h*0.18);
    ctx.closePath();
    ctx.fill();

    // face details
    ctx.fillStyle = '#111827';
    ctx.beginPath();
    ctx.ellipse(w*0.46, h*0.34, 2.2, 3, 0,0,Math.PI*2);
    ctx.ellipse(w*0.54, h*0.34, 2.2, 3, 0,0,Math.PI*2);
    ctx.fill();

    ctx.fillStyle = '#fb7185';
    ctx.beginPath();
    ctx.ellipse(w*0.50, h*0.38, 3, 2.5, 0,0,Math.PI*2);
    ctx.fill();

    // raised paw
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.roundRect(w*0.68, h*0.22, w*0.18, h*0.22, 12);
    ctx.fill();

    // collar
    ctx.strokeStyle = '#ef4444';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(w*0.38, h*0.48);
    ctx.lineTo(w*0.62, h*0.48);
    ctx.stroke();

    // coin
    ctx.fillStyle = '#fbbf24';
    ctx.beginPath();
    ctx.ellipse(w*0.50, h*0.64, 10, 10, 0,0,Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#92400e';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(w*0.50, h*0.58);
    ctx.lineTo(w*0.50, h*0.70);
    ctx.stroke();
  }

  function drawLantern(w,h){
    // red lantern (overhead)
    ctx.fillStyle = '#ef4444';
    ctx.beginPath();
    ctx.roundRect(8, 6, w-16, h-12, 14);
    ctx.fill();

    // center stripe
    ctx.fillStyle = '#ffffff';
    ctx.globalAlpha = 0.85;
    ctx.beginPath();
    ctx.roundRect(w*0.42, 10, w*0.16, h-20, 10);
    ctx.fill();
    ctx.globalAlpha = 1;

    // string
    ctx.strokeStyle = '#111827';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(w*0.50, 0);
    ctx.lineTo(w*0.50, 8);
    ctx.stroke();
  }

  function drawBanner(w,h){
    // hanging banner (overhead)
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.roundRect(10, 8, w-20, h-16, 10);
    ctx.fill();

    // red top
    ctx.fillStyle = '#ef4444';
    ctx.beginPath();
    ctx.roundRect(10, 8, w-20, 10, 8);
    ctx.fill();

    // symbol
    ctx.fillStyle = '#111827';
    ctx.globalAlpha = 0.75;
    ctx.beginPath();
    ctx.ellipse(w*0.50, h*0.55, 10, 10, 0,0,Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // string
    ctx.strokeStyle = '#111827';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(w*0.50, 0);
    ctx.lineTo(w*0.50, 8);
    ctx.stroke();
  }

  // =====================
  // Collision
  // =====================
  function aabb(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  // =====================
  // Spawning
  // =====================
  function scheduleNextSpawn(){
    const d = DIFF[difficultySel.value] || DIFF.medium;
    // Spawn spacing in seconds, scaled by speed
    const r = d.spawnMin + Math.random() * (d.spawnMax - d.spawnMin);
    nextSpawnIn = r;
  }

  function spawn(){
    // Avoid too many overhead in a row
    const pick = OB_TYPES[Math.floor(Math.random()*OB_TYPES.length)];

    // Ensure overhead appears often enough to require duck
    let chosen = pick;
    if(Math.random() < 0.30){
      chosen = {id: Math.random()<0.5?'lantern':'banner', kind:'over'};
    }

    const o = makeObstacle(chosen.id, chosen.kind);

    // Ensure not glued: keep a minimum gap in pixels from last obstacle
    const last = obstacles[obstacles.length-1];
    if(last){
      const minGap = 210 + Math.random()*120;
      if(o.x - (last.x + last.w) < minGap){
        o.x = last.x + last.w + minGap;
      }
    }

    obstacles.push(o);
  }

  // =====================
  // Game flow
  // =====================
  function resetGame(){
    running = false;
    gameOver = false;
    countdown = 0;
    score = 0;
    lastTingBucket = 0;
    time = 0;
    speed = 1;
    obstacles = [];
    scheduleNextSpawn();

    ninja.vy = 0;
    ninja.onGround = true;
    ninja.ducking = false;
    ninja.anim = 0;

    // place ninja on ground
    ninja.y = groundY() - ninja.h;

    scoreEl.textContent = '0';
    spdEl.textContent = '1.0';

    overlayTitle.textContent = 'Ninja Runner';
    overlayDesc.textContent = 'Nh·∫≠p t√™n, ch·ªçn ƒë·ªô kh√≥, b·∫•m B·∫Øt ƒë·∫ßu. Space/‚Üë nh·∫£y, ‚Üì c√∫i.';
    overlay.style.display = 'flex';
  }

  function startCountdown(){
    if(!playerName){
      playerName = (playerNameInput.value || '').trim();
    }
    if(!playerName){
      playerName = 'Player';
    }

    // Resume audio on user gesture if possible
    ensureAudio();
    if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();

    running = true;
    gameOver = false;
    countdown = 3;
    countdownStart = performance.now();
    overlay.style.display = 'none';

    // Ensure correct y
    ninja.y = groundY() - ninja.h;

    // Clear obstacles and schedule
    obstacles = [];
    scheduleNextSpawn();
  }

  function endGame(){
    if(gameOver) return;
    gameOver = true;
    running = false;

    // Save leaderboard
    const list = loadLB();
    list.push({name: playerName || 'Player', score});
    const sorted = list.sort((a,b)=>b.score-a.score).slice(0,10);
    saveLB(sorted);
    renderLB();

    overlayTitle.textContent = 'Game Over üí•';
    overlayDesc.textContent = `ƒêi·ªÉm c·ªßa b·∫°n: ${score}. Nh·∫•n B·∫Øt ƒë·∫ßu ƒë·ªÉ ch∆°i l·∫°i.`;
    overlay.style.display = 'flex';
  }

  // =====================
  // Input
  // =====================
  function doJump(){
    if(!running || gameOver) return;
    if(countdown > 0) return;
    if(ninja.onGround){
      ninja.vy = JUMP.vy;
      ninja.onGround = false;
      ninja.jumpHoldStart = performance.now();
    }
  }

  function setDuck(on){
    if(!running || gameOver) return;
    if(countdown > 0) return;
    ninja.ducking = on;
  }

  window.addEventListener('keydown', (e) => {
    if(e.code === 'Space' || e.code === 'ArrowUp'){
      e.preventDefault();
      keys.jump = true;
      doJump();
    }
    if(e.code === 'ArrowDown'){
      e.preventDefault();
      keys.duck = true;
      setDuck(true);
    }
    if(e.code === 'Enter'){
      if(overlay.style.display !== 'none'){
        startCountdown();
      }
    }
  });

  window.addEventListener('keyup', (e) => {
    if(e.code === 'Space' || e.code === 'ArrowUp'){
      keys.jump = false;
    }
    if(e.code === 'ArrowDown'){
      keys.duck = false;
      setDuck(false);
    }
  });

  // Mobile
  btnJump.addEventListener('pointerdown', (e)=>{ e.preventDefault(); doJump(); });
  btnDuck.addEventListener('pointerdown', (e)=>{ e.preventDefault(); setDuck(true); });
  btnDuck.addEventListener('pointerup', ()=> setDuck(false));
  btnDuck.addEventListener('pointercancel', ()=> setDuck(false));

  // Buttons
  playBtn.addEventListener('click', startCountdown);
  startBtn.addEventListener('click', () => {
    if(overlay.style.display !== 'none'){
      startCountdown();
    }else{
      // If already in game, restart
      startCountdown();
    }
  });

  resetBtn.addEventListener('click', resetGame);

  // =====================
  // Update loop
  // =====================
  let last = performance.now();

  function tick(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    // Always draw
    update(dt, now);
    draw(now);

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  function update(dt, now){
    // keep ninja on ground if not running
    if(!running){
      ninja.y = groundY() - ninja.h;
      return;
    }

    // countdown
    if(countdown > 0){
      const elapsed = now - countdownStart;
      const step = Math.floor(elapsed / 1000);
      const left = 3 - step;
      countdown = Math.max(0, left);
      if(countdown === 0){
        // start actual play
        time = 0;
        score = 0;
        lastTingBucket = 0;
        obstacles = [];
        scheduleNextSpawn();
      }
      return;
    }

    // speed
    const d = DIFF[difficultySel.value] || DIFF.medium;
    time += dt;
    const base = d.baseSpeed;
    const s = base + time * (base * d.accel);
    speed = s;
    spdEl.textContent = (speed / d.baseSpeed).toFixed(1);

    // score (steady)
    score += dt * 10;
    const scoreInt = Math.floor(score);
    scoreEl.textContent = String(scoreInt);

    // ting each 10 points
    const bucket = Math.floor(scoreInt / 10);
    if(bucket > lastTingBucket){
      lastTingBucket = bucket;
      ting();
    }

    // Ninja physics
    // Variable jump: if holding jump early, slightly reduce gravity
    const holding = keys.jump && !ninja.onGround && (performance.now() - ninja.jumpHoldStart) < JUMP.maxHoldMs;
    const grav = holding ? JUMP.gravity * 0.78 : JUMP.gravity;

    ninja.vy += grav * dt;
    ninja.y += ninja.vy * dt;

    const gy = groundY();
    const floor = gy - ninja.h;
    if(ninja.y >= floor){
      ninja.y = floor;
      ninja.vy = 0;
      ninja.onGround = true;
    }else{
      ninja.onGround = false;
    }

    // Run animation
    ninja.anim += dt;
    if(!ninja.onGround) ninja.anim += dt*0.8;

    // Spawn
    nextSpawnIn -= dt;
    if(nextSpawnIn <= 0){
      spawn();
      scheduleNextSpawn();
    }

    // Move obstacles
    const vx = speed * dt;
    for(const o of obstacles){
      o.x -= vx;
    }

    // Remove offscreen
    obstacles = obstacles.filter(o => o.x + o.w > -40);

    // Collision
    const nh = ninjaHitbox();
    for(const o of obstacles){
      const oh = obstacleHitbox(o);
      if(aabb(nh, oh)){
        endGame();
        break;
      }
    }
  }

  function draw(now){
    const w = W();
    const h = H();

    ctx.clearRect(0,0,w,h);

    // Background
    drawBackground(now/1000);

    // Obstacles
    for(const o of obstacles){
      drawObstacle(o);
    }

    // Ninja
    drawNinja();

    // Countdown overlay inside canvas
    if(running && countdown > 0){
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,.75)';
      ctx.fillRect(0,0,w,h);
      ctx.fillStyle = '#111827';
      ctx.font = '900 72px ui-sans-serif, system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(countdown), w/2, h/2 - 10);
      ctx.font = '600 16px ui-sans-serif, system-ui';
      ctx.fillStyle = '#6b7280';
      ctx.fillText('Chu·∫©n b·ªã...', w/2, h/2 + 44);
      ctx.restore();
    }

    // If game over but overlay hidden (rare)
    if(gameOver && overlay.style.display === 'none'){
      overlay.style.display = 'flex';
    }
  }

  // Init
  resetGame();
})();
</script>
</body>
</html>